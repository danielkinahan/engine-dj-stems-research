#!/usr/bin/env python3
"""
Analyze the extracted keys mathematically to find patterns.
"""

# The 10 keys we extracted (first 16 bytes of each for analysis)
keys_hex = [
    "3a81b058700c860ed3b8efe2dfb07b61",  # Key 1
    "5d077ad9cd3936d0c958a90508 8b39f0",  # Key 2
    "1209f67e1b1a003e00ffd9a74a1208e6",  # Key 3
    "9ffa55d49f19be595d07cfdb619d8d22",  # Key 4
    "69dda9d2bb5229b34164b52fb6f12bd4",  # Key 5
    "ecccb9edfafacf3ac1060799 5acba0d0",  # Key 6
    "ef23613edb7a8488ab7299 22a6b58fbd",  # Key 7
    "fd3210da84138bc734bf9c4cab01a7bd",  # Key 8
    "e6c37f67091c48a73312cafa1b28e341",  # Key 9
    "717331 17e864710ce2f308c4b2047f62",  # Key 10
]

# Clean up hex strings (remove spaces)
keys_hex = [k.replace(" ", "") for k in keys_hex]

print("="*70)
print("MATHEMATICAL PATTERN ANALYSIS OF EXTRACTED KEYS")
print("="*70)

# Convert to bytes
keys = [bytes.fromhex(k) for k in keys_hex]

print("\nKey 1 (Frame 1):", keys_hex[0])
print("Key 2 (Frame 2):", keys_hex[1])
print()

# Check XOR differences
print("XOR Analysis (Key2 XOR Key1):")
xor_1_2 = bytes(a ^ b for a, b in zip(keys[0], keys[1]))
print(" ".join(f"{b:02x}" for b in xor_1_2))
print()

print("XOR Analysis (Key3 XOR Key2):")
xor_2_3 = bytes(a ^ b for a, b in zip(keys[1], keys[2]))
print(" ".join(f"{b:02x}" for b in xor_2_3))
print()

print("XOR Analysis (Key3 XOR Key1):")
xor_1_3 = bytes(a ^ b for a, b in zip(keys[0], keys[2]))
print(" ".join(f"{b:02x}" for b in xor_1_3))
print()

# Check if XOR differences are consistent (stream cipher pattern)
print("Checking if XOR difference between consecutive keys is constant:")
xor_diffs = []
for i in range(len(keys) - 1):
    xor_diff = bytes(a ^ b for a, b in zip(keys[i], keys[i+1]))
    xor_diffs.append(xor_diff)
    
# Check if all XOR diffs are the same
all_same = all(xor_diffs[0] == xor_diff for xor_diff in xor_diffs)
if all_same:
    print("✓ YES! Stream cipher with constant XOR difference")
    print("XOR constant:", " ".join(f"{b:02x}" for b in xor_diffs[0]))
else:
    print("✗ NO - XOR differences vary")
    print()

# Statistical analysis
print("\nStatistical Analysis:")
print("-" * 70)

for idx, key in enumerate(keys, 1):
    # Count bits
    bit_count = sum(bin(b).count('1') for b in key)
    avg_byte = sum(key) / len(key)
    
    print(f"Key {idx}: {bit_count:3d} bits set, avg byte value: {avg_byte:6.2f}")

print()

# Check for incrementing patterns in individual bytes
print("Byte-by-byte differences (Key_n+1[i] - Key_n[i]):")
print("-" * 70)

for byte_idx in range(16):  # First 16 bytes
    diffs = []
    for key_idx in range(len(keys) - 1):
        diff = (keys[key_idx + 1][byte_idx] - keys[key_idx][byte_idx]) % 256
        diffs.append(diff)
    
    # Check if differences are consistent
    if len(set(diffs)) == 1:
        print(f"Byte {byte_idx:2d}: constant diff = {diffs[0]:3d} (0x{diffs[0]:02x})")
    else:
        # Show first few diffs
        diff_str = ", ".join(f"{d:3d}" for d in diffs[:5])
        print(f"Byte {byte_idx:2d}: varying - first 5 diffs: [{diff_str}...]")

print()
print("="*70)
print("CONCLUSION")
print("="*70)

if all_same:
    print("Keys generated using: Stream cipher (CTR mode likely)")
    print("Key[n] = Key[0] XOR (constant * n)")
else:
    print("Keys appear pseudo-random - likely generated by:")
    print("  1. Cryptographic hash (MD5/SHA256 of seed + frame_index)")
    print("  2. PRNG seeded with UUID + frame_index")
    print("  3. Key derivation function (PBKDF2, HKDF)")
    print()
    print("Next steps:")
    print("  - Hook RAND_bytes to see if PRNG is used")
    print("  - Search for frame_index/counter being passed to crypto functions")
    print("  - Check if Windows CNG (bcryptPrimitives.dll) is used instead")
